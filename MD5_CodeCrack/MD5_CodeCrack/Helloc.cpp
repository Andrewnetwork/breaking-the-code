// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation. All rights reserved.


/****************************************************************************
						Microsoft RPC
           
                       Hello Example

    FILE:       helloc.c

    USAGE:      helloc  -n network_address
                        -p protocol_sequence
                        -a server principal name
                        -e endpoint
                        -o options
                        -s string_displayed_on_server

    PURPOSE:    Client side of RPC distributed application

    FUNCTIONS:  main() - binds to server and calls remote procedure

    COMMENTS:   This version of the distributed application that
                prints "hello, world" (or other string) on the server
                features a client that manages its connection to the
                server. It uses the binding handle hello_IfHandle,
                defined in the file hello.h.

****************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include "hello.h"    // header file generated by MIDL compiler
#include "spn.h"
#include <iostream>
#include <string>
#include "md5.h"
using namespace std;

const unsigned int MAX_N_SETS = 10;

const unsigned int hashDecodedSize = 20;

const unsigned int BREAK_HASH_SIZE = 10;

// Return value:
//   [] NULL -> Did not break hash. 
//   [] C String -> Did break hash.  
unsigned char * generateAndCheckPermutationsInRange(char hash[ ],char alphabet[] , unsigned int alphabetSize, unsigned long start, unsigned long end);

void Usage(char * pszProgramName)
{
    fprintf_s(stderr, "Usage:  %s\n", pszProgramName);
    fprintf_s(stderr, " -p protocol_sequence\n");
    fprintf_s(stderr, " -n network_address\n");
    fprintf_s(stderr, " -e endpoint\n");
    fprintf_s(stderr, " -a server principal name\n");	
    fprintf_s(stderr, " -o options\n");
    fprintf_s(stderr, " -s string\n");
    exit(1);
}

void __cdecl main(int argc, char **argv)
{
    RPC_STATUS status;
    unsigned char * pszUuid             = NULL;
    unsigned char pszProtocolSequence[13] = "ncacn_ip_tcp";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char pszEndpoint[ 5 ]  = "8765";
    unsigned char * pszSpn              = NULL;	
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding    = NULL;
    unsigned char pszString[13]        = "WOOT";
    RPC_SECURITY_QOS SecQos;
    unsigned long ulCode;


    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.
    status = RpcStringBindingCompose(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pszStringBinding);
    //printf_s("RpcStringBindingCompose returned 0x%x\n", status);
    //printf_s("pszStringBinding = %s\n", pszStringBinding);
    if (status) {
        exit(status);
    }

    // Set the binding handle that will be used to bind to the server.
    status = RpcBindingFromStringBinding(pszStringBinding,
                                         &hello_IfHandle);
    //printf_s("RpcBindingFromStringBinding returned 0x%x\n", status);
    if (status) {
        exit(status);
    }

    // User did not specify spn, construct one.
    if (pszSpn == NULL) {
        MakeSpn(&pszSpn);
    }

    // Set the quality of service on the binding handle
    SecQos.Version = RPC_C_SECURITY_QOS_VERSION_1;
    SecQos.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    SecQos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    SecQos.ImpersonationType = RPC_C_IMP_LEVEL_IDENTIFY;

    // Set the security provider on binding handle
    status = RpcBindingSetAuthInfoEx(hello_IfHandle,
                                     pszSpn,
                                     RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                     RPC_C_AUTHN_GSS_NEGOTIATE,
                                     NULL,
                                     RPC_C_AUTHZ_NONE,
                                     &SecQos);
	
    //printf_s("RpcBindingSetAuthInfoEx returned 0x%x\n", status);
    if (status) {
        exit(status);
    }	
	
    //printf_s("Calling the remote procedure 'HelloProc'\n");
    //printf_s("Print the string '%s' on the server\n", pszString);


	//************************ BEGIN RPC ACTIVITY ***********************
    RpcTryExcept 
	{
		/*
		char alphabet[] = {
			// Capital Letters
			'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
			// Lowercase Letters 
			'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
			// Digits 
			'0','1','2','3','4','5','6','7','8','9',
			// Special Characters
			'!','.','?'
		};*/

		
		char MD5_alphabet[] = {
			'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','\0'
		};

		unsigned long int start[1]; 
		unsigned long int end[1]; 
		unsigned char breakHash[ BREAK_HASH_SIZE ];
		bool crackedHash = false;
		unsigned char * hashDecoded;

		GetHash( hello_IfHandle, breakHash );

		while( !crackedHash )
		{
			
			GetPermutationRange(hello_IfHandle, start, end );
			hashDecoded = generateAndCheckPermutationsInRange((char * )breakHash ,MD5_alphabet , sizeof(MD5_alphabet), *start,  *end);

			
			if ( hashDecoded != NULL )
			{
				HashDecoded( hello_IfHandle, (unsigned char * )hashDecoded );
				crackedHash = true;
			}

		}	
	

    }
    RpcExcept(( ( (RpcExceptionCode() != STATUS_ACCESS_VIOLATION) &&
                   (RpcExceptionCode() != STATUS_DATATYPE_MISALIGNMENT) &&
                   (RpcExceptionCode() != STATUS_PRIVILEGED_INSTRUCTION) &&
                   (RpcExceptionCode() != STATUS_BREAKPOINT) &&
                   (RpcExceptionCode() != STATUS_STACK_OVERFLOW) &&
                   (RpcExceptionCode() != STATUS_IN_PAGE_ERROR) &&
                   (RpcExceptionCode() != STATUS_GUARD_PAGE_VIOLATION)
                    )
                    ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )) {
        ulCode = RpcExceptionCode();
        printf_s("Runtime reported exception 0x%lx = %ld\n", ulCode, ulCode);

	  
    }
    RpcEndExcept
	//************************END RPC ACTIVITY ***********************

	system("pause");
    //  The calls to the remote procedures are complete.
    //  Free the string and the binding handle
    status = RpcStringFree(&pszStringBinding);  // remote calls done; unbind
    printf_s("RpcStringFree returned 0x%x\n", status);
    if (status) {
        exit(status);
    }
	
    status = RpcBindingFree(&hello_IfHandle);  // remote calls done; unbind
    printf_s("RpcBindingFree returned 0x%x\n", status);
    if (status) {
        exit(status);
    }
	

	system("pause");
    exit(0);

}  // end main()


/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void  __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}


// ########### Permutation generation #################

void initilizeCounter(int nums[] , int alphabetSize, int incrementAmt)
{
	if( incrementAmt != 0 )
	{

		unsigned long int remainder = incrementAmt; 

		int digitCount = 1;

		do
		{
			nums[MAX_N_SETS - digitCount ] = remainder % alphabetSize; 

			remainder = remainder / alphabetSize;

			digitCount++;

		}while(remainder > 0);

	}

}

void increment(int nums[] , int alphabetSize)
{
	for(int digitIndex = MAX_N_SETS - 1; digitIndex >= 0; digitIndex--)
	{
		if(nums[digitIndex] + 1 >= alphabetSize )
		{
			nums[digitIndex] = 0;
		}
		else
		{
			nums[digitIndex] += 1; 
			digitIndex = -1; // Done
		}
	}
}

bool isZeroFilled(int counters[] )
{
	// This function determnines if there are all zeros in a numerical array.
	for(int i = 0; i < MAX_N_SETS; i++)
	{
		if(counters[i] != 0)
		{
			
			return false;
		}
	}

	return true;
}



unsigned char * getPermutation(char alphabet[] , unsigned int sizeOfAlphabet, int counters[] )
{
	unsigned char * permutation = new unsigned char[MAX_N_SETS + 1]; 

	int i;

	for(i = 0; i < MAX_N_SETS; i++)
	{
		permutation[i] =  alphabet[ counters[i] ];
	}

	permutation[ MAX_N_SETS ] = '\0';

	return permutation;
}

char * MD5_string(unsigned char *string)
{
    MD5 context;
    unsigned int len = strlen ( (char *)string);

    context.update   (string, len);
    context.finalize ();

    return context.hex_digest();
  
}

// Inclusive range
unsigned char * generateAndCheckPermutationsInRange(char breakHash[ ], char alphabet[] , unsigned int alphabetSize, unsigned long start, unsigned long end)
{
	//cout<<"Generating permutations from "<<start<<" to "<<end<<endl;
	int counters[MAX_N_SETS] = {0}; 
	unsigned long int counter = 0; 
	bool reachedEnd = false; 
	unsigned char * permutation;

	// Jump to the start of a permutation range.
	initilizeCounter( counters, alphabetSize, start );

	do
	{	
		counter++;

		//The answer is below. 
	
		permutation = getPermutation( alphabet, alphabetSize, counters);

		// Use answer her

		if( strcmp( MD5_string( permutation ), breakHash ) == 0 )
		{
			// The permutation is the breakHash decoded.
			return permutation; 
		}


		increment(counters , alphabetSize);

		if( counter-1 >= (end - start) )
		{
			reachedEnd = true;
		}

	}while( !isZeroFilled( counters ) && !reachedEnd );

	//cout<<endl<<"Total number of permutations: "<<counter<<endl;
	//cout<<"Done."<<endl;
	return NULL;
}







// end file helloc.c
